//* Дескрипторы объектов
const car = {
    brand: 'Porsche',
    year: 2018,
    get age() {
        return `Машина выпущена в ${this.year}`
    }, //* Так же геттер можно обьявлять и через объект
    //* Сеттеры
    set age(value) {
        this.year = value;
    } //* Изменит свойства car.age = 2020 => {brand: "Porsche", year: 2020} (Так же сюда можно записывать проверки)
};

//* Геттеры и сеттроры дают возможность контралировать взаимодействие с каким либо свойством объекта и не давать изменять его свойства при не верных условиях. Геттеры и сеттроры не попадут в новый обьект при копировании.

//* Метод Object.defineProperty()(определение свойства) определяет новое или изменяет существующее свойство непосредственно на объекте, возвращая этот объект.
//* Первый параметр - сам обьъект , второй - тот что мы хотим изменить, третий обьект - дескриптор(который имеет некоторые настройки)

Object.defineProperty(car, /* 'year' */ 'age', {
    configurable: false,  //* не дает возможность удалить или как-то изменит 'year' свойство
    enumerable: false,  //* делает в свойство(в данном случае 'year')не итерируемым Object.keys(car);["brand"]
    writable: false,  //* заприщает запись\перапись  данного свойства, но его можно удалить
});

//* Геттер - помогает скрыть какую-то логику(один из принцепов ООП - инкопсюляция) (Но мы вызвали его как функцию, а не метод)
/* get: function () {
    return `Машина выпущена в ${this.year}` //* 'age' - "Машина выпущена в 2018"
} */

//! Возможный хитрый вопрос на собеседовании
//* Какая-то функция перезаписывает глобальнуе переменную которая ломает весь код

Object.defineProperty(window, 'globalVar', //* обьявить дескриптор и задать set 
    {
        set: function (value) {
            console.log();
            debugger; //* выбросит на то место где было прозведено изменение данного свойства
        }
    });


function foo() {
    globalVar = 10;
}

foo();